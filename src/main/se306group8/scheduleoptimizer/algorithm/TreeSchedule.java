package se306group8.scheduleoptimizer.algorithm;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import se306group8.scheduleoptimizer.taskgraph.Dependency;
import se306group8.scheduleoptimizer.taskgraph.Schedule;
import se306group8.scheduleoptimizer.taskgraph.Task;
import se306group8.scheduleoptimizer.taskgraph.TaskGraph;

/** This is class that is used to wrap the very compressed representation that is used for ScheduleStorage. It is
 * not intended to be used for the storage itself, as the fact that it is an object instantly requires that it takes up
 * 16B, and usually 24B. Using clever compression we can store each schedule in 10B, doubling the number of solutions we can
 * store. */
public class TreeSchedule {
	
	//Constructed fields
	private final TreeSchedule parent;
	private final Task task; 
	private final int processor, lowerBound;
	private final TaskGraph graph;
	
	//Calculated fields
	
	public TreeSchedule(TaskGraph graph, TreeSchedule parent, Task task, int processor, int lowerBound) {
		this.graph = graph;
		this.parent = parent;
		this.task = task;
		this.processor = processor;
		this.lowerBound = lowerBound;
	}
	
	/** Returns a collection of child schedules that can be generated by adding one task to this solution.
	 * This list may not be exhaustive, but any omissions must have equivalent schedules returned by some PartialSolution.
	 * 
	 *  Equivalent means that the solution tree generated by the other task is a super tree of the tree generated by the omitted task.
	 *  A super tree is a tree where every task in the original tree has an equivalent task in the super tree. */
	public List<TreeSchedule> getGreedyChildSchedules() {
		
		// get list of all tasks that can be scheduled next
		List<Task> nextTasks = new ArrayList<Task>();
		
		for(Task task : graph.getAll()) {
			boolean canScheduleNext = true;
			// check that all parents have already been scheduled
			for (Dependency parent : task.getParents()) {
				if (!this.graph.getAll().contains(parent.getSource())) {
					canScheduleNext = false;
				}
			}
			if (canScheduleNext) {
				nextTasks.add(task);
			}
		}
		
		// Robert's greedy code here. Allocate each task to a processor and output schedule.
		// maybe this method should return only the best schedule?
		
		// don't know the best task/processor yet
		Task bestTask = null;
		int bestProcessor = 0;
		
		// how to calculate lower bound?
		List<TreeSchedule> childSchedules = new ArrayList<TreeSchedule>();
		
		/*for (Task task : nextTasks) {
			for (int processor : ????) {
				
				int newLowerBound = lowerBound + task.getCost();
				childSchedules.add(new TreeSchedule(graph, this, task, processor, newLowerBound));
			}
		}*/
		
		return childSchedules;
	}
	
	public List<List<Task>> computeTaskLists() {
		List<List<Task>> result;
		if(parent == null) {
			result = new ArrayList<>();
		} else {
			result = parent.computeTaskLists();
		}
		
		while(result.size() < processor) {
			result.add(new ArrayList<>());
		}
		
		result.get(processor).add(task);
		
		return result;
	}
	
	/** Returns the full schedule. This may be null if this solution is not a full solution. */
	public Schedule getFullSchedule() {
		return new ListSchedule(graph, computeTaskLists());
	}
	
	public Task getMostRecentTask() {
		return task;
	}
	
	public int getMostRecentProcessor() {
		return processor;
	}

	public TreeSchedule getParent() {
		return parent;
	}

	public int getLowerBound() {
		return lowerBound;
	}
}
