package se306group8.scheduleoptimizer.algorithm.childfinder;

import java.util.ArrayList;
import java.util.List;

import se306group8.scheduleoptimizer.algorithm.ProcessorAllocation;
import se306group8.scheduleoptimizer.algorithm.TreeSchedule;
import se306group8.scheduleoptimizer.taskgraph.Dependency;
import se306group8.scheduleoptimizer.taskgraph.Task;

/**
 * This child finder attempts to remove all duplicate children and equivalent children, so that only one of each equivalence class is explored.
 * It does not attempt to ensure that all children are generated, only that all complete children can be generated.
 * 
 * Firstly, each child can only be generated by it's best parent. The goodness of a parent is governed by the sum of the ids it has yet to schedule. Only parents
 * that can actually exist are considered.
 * 
 * In certain cases the order that tasks are considered is fixed, in this case each task that is fixed is considered locked in place, and cannot be considered for removal by the parent selection system.
 * If it is an option, the ordering based on these runs of tasks should be preferred as the method of reaching the child solutions.
 * 
 * At the moment the duplicate removal system is disabled.
 */
public class DuplicateRemovingChildFinder implements ChildScheduleFinder {
	private final int processors;
	public DuplicateRemovingChildFinder(int processors) {
		this.processors = processors;
	}
	
	@Override
	public List<TreeSchedule> getChildSchedules(TreeSchedule schedule) {
		//Only add the schedule if it is the earliest schedule that can create it.
		//Schedule a is smaller than schedule b if 
		List<TreeSchedule> childrenSchedules = new ArrayList<>(processors * schedule.getAllocatable().size());
		int largestRoot = schedule.getLargestRoot();
		
		if(schedule.isFixed()) {
			Task nextTaskInFixedOrder = schedule.getAllocatable().get(0);
			
			for(int p = 1; p <= schedule.getNumberOfUsedProcessors(); p++) {
				if(checkFixedOrder(nextTaskInFixedOrder, p, schedule)) {
					childrenSchedules.add(new TreeSchedule(nextTaskInFixedOrder, p, schedule));
				}
			}
			
			if(schedule.getNumberOfUsedProcessors() != processors) { //We can always allocate on the next empty processor, regardless of fixed order.
				for (Task task : schedule.getAllocatable()) {
					if(task.getId() > largestRoot) {
						//No need to check, we are on the last processor anyway
						childrenSchedules.add(new TreeSchedule(task, schedule.getNumberOfUsedProcessors() + 1, schedule));
					}
				}
			}
		} else {
			for (Task task : schedule.getAllocatable()) {
				//Make sure that the processors are allocated in the order of the first task on each processor.
				int processorsToAllocate;
				if(task.getId() > schedule.getLargestRoot()) {
					processorsToAllocate = Math.min(schedule.getNumberOfUsedProcessors() + 1, processors);
				} else {
					processorsToAllocate = schedule.getNumberOfUsedProcessors();
				}

				for (int p = 1; p <= processorsToAllocate; p++) {
					if(checkFixedOrder(task, p, schedule)) {
						childrenSchedules.add(new TreeSchedule(task, p, schedule));
					}
				}
			}
		}

		return childrenSchedules;
	}
	
	private boolean checkFixedOrder(Task task, int processor, TreeSchedule schedule) {
		ProcessorAllocation alloc = schedule.getLastAllocationForProcessor(processor);
		
		if(alloc == null)
			return true;
		
		Task otherTask = alloc.task;
		
		if(task.isParent(otherTask)) {
			return true;
		}
		
		if(task.getChildren().size() > 1 || task.getParents().size() > 1)
			return true;
		
		if(alloc.task.getChildren().size() > 1 || task.getParents().size() > 1)
			return true;
		
		boolean mustSwapIfValid = task.getId() < otherTask.getId();
		
		if(otherTask.getChildren().size() == 1) {
			if(task.getChildren().size() == 1 && alloc.task.getChildren().size() == 1) {
				Dependency thisDep = task.getChildren().get(0);
				Dependency otherDep = otherTask.getChildren().get(0);

				if(!thisDep.getTarget().equals(otherDep.getTarget())) {
					return true; //Cannot say anything about the order.
				}

				if(thisDep.getCommunicationCost() < otherDep.getCommunicationCost()) {
					return true; //Cannot swap as it would worsen the child horizon
				} else if(thisDep.getCommunicationCost() > otherDep.getCommunicationCost()) {
					mustSwapIfValid = true; //Swapping might reduce child start time
				}
			} else {
				//We can't swap, as the other task has a child linkage and we don't
				return true;
			}
		} else {
			if(task.getChildren().size() == 1) {
				//We have children, we should swap to start earlier
				mustSwapIfValid = true;
			}
		}
		
		if(task.getParents().size() == 1) {
			if(otherTask.getParents().size() == 1) {
				Dependency thisDep = task.getParents().get(0);
				Dependency otherDep = otherTask.getParents().get(0);

				if(!thisDep.getSource().equals(otherDep.getSource())) {
					return true; //Cannot say anything about the order.
				}

				if(thisDep.getCommunicationCost() > otherDep.getCommunicationCost()) {
					return true; //Cannot swap as it could worsen the swapping order.
				} else if(thisDep.getCommunicationCost() < otherDep.getCommunicationCost()) {
					mustSwapIfValid = true; //Swapping might reduce the start time.
				}
			} else {
				//We a parent but the other task does not. We should not swap
				return true;
			}
		} else {
			if(otherTask.getParents().size() == 1) {
				mustSwapIfValid = true; //The other has a parent, and we do not, it should go first.
			}
		}
		
		return !mustSwapIfValid; //If we can't swap, this order is valid.
	}
	
	private boolean checkHorizon(Task task, int processor, TreeSchedule schedule) {
		//If these two tasks can be swapped
		int positionOfNewTask = schedule.getNumberOfTasksOnProcessor(processor); //The 0 indexed position of the new task
		
		//Decrement position until index order has been reached. If at any of those positions a same of better schedule is found
		//return false, else return true;
		
		List<ProcessorAllocation> allocations = new ArrayList<>(schedule.getNumberOfTasksOnProcessor(processor)); //The list of tasks other than the scheduled task on this processor
		
		ProcessorAllocation alloc = schedule.getLastAllocationForProcessor(processor);
		while(alloc != null) {
			allocations.add(alloc);
		}
		
		int[] startTimes = new int[schedule.getGraph().getAll().size()];
		for(ProcessorAllocation t : allocations) {
			startTimes[t.task.getId()] = t.startTime;
		}
		
		//Move the new task to the position before the swapTarget
		swap:
		for(int swapTarget = allocations.size() - 1; swapTarget >= 0; swapTarget--) {
			Task target = allocations.get(swapTarget).task;
			if(task.isParent(target) || task.getId() > target.getId()) { //We can't swap, this ordering is valid.
				return true;
			}
			
			int taskStartTime = schedule.getDataReadyTime(task);
			if(swapTarget != 0) {
				taskStartTime = Math.max(allocations.get(swapTarget - 1).endTime, taskStartTime);
			}
			
			//Populate the start times for the other tasks
			//Only worry about tasks ahead of the swap, and the task itself
			for(int p = swapTarget; p < allocations.size(); p++) {
				int startTime = schedule.getDataReadyTime(allocations.get(p).task);
				if(p == swapTarget) {
					startTime = Math.max(startTime, taskStartTime + task.getCost());
				} else {
					startTime = Math.max(startTime, startTimes[allocations.get(p - 1).task.getId()] + allocations.get(p - 1).task.getCost());
				}
				
				startTimes[allocations.get(p).task.getId()] = startTime;
				
				if(startTime <= allocations.get(p).startTime) {
					return false; //This task is scheduled the same or better. Therefore all tasks after it will also be scheduled the same or better
				} else if(startTime > schedule.getRequiredBy(allocations.get(p).task)) {
					continue swap; //This item was scheduled too late. The swap may not be valid. Continue to next swap
				} else {
					//Check the comms to tasks that have not been scheduled yet.
					
				}
			}
		}
	}
	
	//Ensures that the parent schedule is the earliest schedule that can produce this child.
	private boolean isBestParent(Task task, int processor, TreeSchedule schedule) {
		//Look at each task on the top of the processor, if it is a later task then the schedule is not valid, provided removing it leaves a valid schedule.
		for(int p = 1; p <= schedule.getNumberOfUsedProcessors(); p++) {
			if(p != processor) {
				ProcessorAllocation alloc = schedule.getLastAllocationForProcessor(p);

				if(alloc.task.getId() <= task.getId()) {
					continue;
				}

				if(p != schedule.getNumberOfUsedProcessors() && schedule.getNumberOfTasksOnProcessor(p) == 1) {
					//We can't remove this one, as it would leave a processor free in the middle of the run
					continue;
				}

				if(!schedule.isRemovable(alloc.task) || task.isParent(alloc.task)) {
					continue; //This task is needed for child - parent reasons
				}

				return false;
			}
		}
		
		return true;
	}
}