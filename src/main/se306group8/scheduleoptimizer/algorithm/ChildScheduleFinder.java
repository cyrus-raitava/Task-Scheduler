package se306group8.scheduleoptimizer.algorithm;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.stream.IntStream;

import se306group8.scheduleoptimizer.taskgraph.Task;
import se306group8.scheduleoptimizer.taskgraph.TaskGraph;

public class ChildScheduleFinder implements IChildScheduleFinder {

	/** Returns a collection of child schedules that can be generated by adding one task to this solution.
	 * This list may not be exhaustive, but any omissions must have equivalent schedules returned by some PartialSolution.
	 * 
	 *  Equivalent means that the solution tree generated by the other task is a super tree of the tree generated by the omitted task.
	 *  A super tree is a tree where every task in the original tree has an equivalent task in the super tree. */
	@Override
	public Collection<TreeSchedule> getChildSchedules(TreeSchedule schedule) {
		
		TaskGraph graph = schedule.getGraph();

		List<Task> nextTasks = getNextTasks(graph, schedule);
		
		// Get an array of integers that represents used processors and next empty processor
		int[] processors = IntStream.rangeClosed(1, schedule.getMostRecentProcessor() + 1).toArray();
		
		Collection<TreeSchedule> childSchedules = new HashSet<TreeSchedule>();
		
		for (Task task : nextTasks) {
			for (int processor : processors) {
				// How to calculate lower bound ??
				int childLowerBound = 0;
				childSchedules.add(new TreeSchedule(graph, schedule, task, processor, childLowerBound));
			}
		}
		return childSchedules;
	}
	
	/** Returns a list of tasks that are allowed to be scheduled next. 
	 *  Tasks are only returned if all their parent tasks have already been scheduled. */
	private List<Task> getNextTasks(TaskGraph graph, TreeSchedule schedule) {
		
		List<Task> nextTasks = new ArrayList<Task>();
		
		// TODO
		
		return nextTasks;
	}
	
	
}
